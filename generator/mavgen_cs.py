#!/usr/bin/env python
'''
parse a MAVLink protocol XML file and generate a CSharp implementation


'''
import sys, textwrap, os, time, platform
import mavparse, mavtemplate

t = mavtemplate.MAVTemplate()

# todo - refactor this in to the other array
map = {
        'float'    : 'float',
        'double'   : 'double',
        'char'     : 'byte',
        'int8_t'   : 'sbyte',
        'uint8_t'  : 'byte',
        'uint8_t_mavlink_version'  : 'B',
        'int16_t'  : 'Int16',
        'uint16_t' : 'UInt16',
        'int32_t'  : 'Int32',
        'uint32_t' : 'UInt32',
        'int64_t'  : 'Int64',
        'uint64_t' : 'UInt64',
        }

# Map of field type to bitconverter bytedecoding function, and number of bytes used for the encoding
mapType = {
        'float'    : ('ToSingle', 4),
        'double'   : ('ToDouble', 8),
        'int8_t'   : ('ToInt8', 1),
        'uint8_t'   : ('ToUInt8', 1),
        'char'   :   ('ToChar', 1),
        'int16_t'  : ('ToInt16', 2),
        'uint16_t' : ('ToUInt16', 2),
        'int32_t'  : ('ToInt32', 4),
        'uint32_t' : ('ToUInt32', 4),
        'int64_t'  : ('ToInt64', 8),
        'uint64_t' : ('ToUInt64', 8),
        }        
        
        
def generate_preamble(outf, msgs, args, xml):
    print("Generating preamble")
    t.write(outf, """
/*
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: ${FILELIST}

Note: this file has been auto-generated. DO NOT EDIT
*/

using System;
""", {'FILELIST' : ",".join(args)})

def generate_xmlDocSummary(outf, summaryText, tabDepth):
    indent = '\t' * tabDepth
    escapedText = summaryText.replace("\n","\n%s///" % indent)
    outf.write("\n%s/// <summary>\n" % indent)
    outf.write("%s/// %s\n" % (indent, escapedText))
    outf.write("%s/// </summary>\n" % indent)
    
    
def generate_enums(outf, enums):
    print("Generating enums")
    outf.write("namespace MavLink\n{\n")
    for e in enums:
        if len(e.description) > 0:
            generate_xmlDocSummary(outf, e.description, 1)
        outf.write("\tpublic enum %s : ushort\n\t{\n" % e.name)

        for entry in e.entry:
            if len(entry.description) > 0:
                generate_xmlDocSummary(outf, entry.description, 2)
            outf.write("\t\t%s = %u,\n" % (entry.name, entry.value))

        outf.write("\n\t}\n\n")
    outf.write("\n}\n")
        
def generate_classes(outf, msgs):
    print("Generating class definitions")
   
    outf.write("namespace MavLink\n{\n")
   
    for m in msgs:
        if (len(m.description) >0):
            generate_xmlDocSummary(outf, m.description, 1)
        outf.write("""\tpublic struct Msg_%s
    {
""" % m.name.lower())
    
        for f in m.fields:
            if (f.description.upper() != f.name.upper()):
                generate_xmlDocSummary(outf, f.description, 2)
            if (f.array_length):
                outf.write("\t\tpublic %s[] %s; // Array size %s\n" % (map[f.type], f.name, f.array_length))
            else:
                outf.write("\t\tpublic %s %s;\n" % (map[f.type], f.name))
            
        outf.write("\t}\n\n")    
    outf.write("}\n\n")

    
   
def generate_Deserialization(outf, messages):
    outf.write("""
/*
MAVLink protocol implementation (auto-generated by mavgen.py)

Note: this file has been auto-generated. DO NOT EDIT
*/

using System;
using System.Collections;
#if MF_FRAMEWORK
#else
using System.Collections.Generic;
#endif

namespace MavLink
{
    public delegate object MavlinkPacketDeserializeFunc(byte[] bytes, int offset);
    
    public class MavLink_Deserializer
    {
#if MF_FRAMEWORK
        internal static MavBitConverter bitconverter = new MavBitConverter();

        public static Hashtable DeserializerLookup = new Hashtable
#else
        private static readonly FrameworkBitConverter bitconverter = new FrameworkBitConverter(); 

        public static Dictionary<int, object> DeserializerLookup = new Dictionary<int, object>
#endif
{""");
    # Create the table of deserialization delegates
    for m in messages:
        outf.write("\n\t\t\t{%s,new MavlinkPacketDeserializeFunc(Deserialize_%s)}," % (m.id,m.name))
    outf.write("\n\t\t};\n")
    
    for m in messages:
        classname="Msg_%s" % m.name.lower()
        outf.write("\n\t\tpublic static object Deserialize_%s(byte[] bytes, int offset)\n\t\t{\n" % (m.name))
        offset = 0
    
        outf.write("\t\t\tvar obj = new %s();\n" % classname)

        for f in m.fields:
            if (f.array_length):
                outf.write("\t\t\tobj.%s =  ByteArrayUtil.%s(bytes, offset + %s, %s);\n" % (f.name, mapType[f.type][0], offset, f.array_length))
                offset += f.array_length
                continue
          
            # mapping 'char' to byte here since there is no real equivalent in the CLR
            if (f.type == 'uint8_t' or f.type == 'char' ):
                    outf.write("\t\t\tobj.%s = bytes[offset + %s];\n" % (f.name,offset))
                    offset+=1          
            else:             
                outf.write("\t\t\tobj.%s = bitconverter.%s(bytes, offset + %s);\n" % (f.name, mapType[f.type][0] ,  offset))
                offset += mapType[f.type][1]
 
        outf.write("\t\t\treturn obj;\n")
        outf.write("\t\t}\n") 
    outf.write("}\n\n")
    outf.write("}\n\n")
	
			
def generate_Serialization(outf, messages):
    
    outf.write("""
namespace MavLink
{
//returns the message ID, offset is advanced by the number of bytes used to serialize
public delegate int MavlinkPacketSerializeFunc(byte[] bytes, ref int offset, object mavlinkPacket);

public class MavLink_Serializer
    {
 #if MF_FRAMEWORK
        internal static MavBitConverter bitconverter = new MavBitConverter();
        public static Hashtable SerializerLookup = new Hashtable
#else
        internal static FrameworkBitConverter bitconverter = new FrameworkBitConverter();
        public static Dictionary<Type, MavlinkPacketSerializeFunc> SerializerLookup = new Dictionary<Type, MavlinkPacketSerializeFunc>
#endif
{
""")

    for m in messages:
        classname="Msg_%s" % m.name.lower()
        outf.write("\n\t\t\t{typeof(%s), new MavlinkPacketSerializeFunc(Serialize_%s)}," % (classname,m.name))
    outf.write("\n\t\t};\n")
    
    # Create the table of serialization delegates
    for m in messages:
        classname="Msg_%s" % m.name.lower()
        outf.write("\n\t\tpublic static int Serialize_%s(byte[] bytes, ref int offset, object obj)\n\t\t{\n" % m.name)
        outf.write("\t\t\tvar msg = (%s)obj;\n\n" % classname)
        offset=0
       
        for f in m.fields:
        
            if (f.array_length):
                outf.write("\t\t\tByteArrayUtil.ToByteArray(msg.%s, bytes, offset + %s, %s);\n" % (f.name, offset, f.array_length))
                offset += f.array_length * mapType[f.type][1]
                continue

            if (f.type == 'uint8_t'):
                outf.write("\t\t\tbytes[offset + %s] = msg.%s;\n" % (offset,f.name))
                offset+=1
            elif (f.type == 'int8_t'):
                outf.write("\t\t\tbytes[offset + %s] = unchecked((byte)msg.%s);\n" % (offset,f.name))
                offset+=1
            elif (f.type == 'char'):
                outf.write("\t\t\tbytes[offset + %s] = msg.%s; // todo: check int8_t and char are compatible\n" % (offset,f.name))
                offset+=1
            else:
                outf.write("\t\t\tbitconverter.GetBytes(msg.%s, bytes, offset + %s);\n" % (f.name,offset))
                offset += mapType[f.type][1]
          
        outf.write("\t\t\toffset += %s;\n" % offset)
        outf.write("\t\t\treturn %s;\n" % m.id)
        outf.write("\t\t}\n") 
    outf.write("\t}\n\n")
    outf.write("}\n\n")

    
def generate(basename, xml):
    '''generate complete MAVLink CSharp implemenation'''
    
   
    
    filename = basename + '.generated.cs'

    msgs = []
    enums = []
    filelist = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))

    print("Generating messages file: %s" % filename)
    dir = os.path.dirname(filename)
    if not os.path.exists(dir):
        os.makedirs(dir)
    outf = open(filename, "w")
    generate_preamble(outf, msgs, filelist, xml[0])
    generate_enums(outf, enums)
    generate_classes(outf, msgs)
    outf.close()
    
    
    
    print("Generating the (De)Serializer classes")
    filename = basename + '_codec.generated.cs'
    outf = open(filename, "w")
    generate_Deserialization(outf, msgs)
    generate_Serialization(outf, msgs)
    outf.close()
    
    print("Copying DLL project and files")
    src = os.path.normpath("CS/include/")
    
    print "Command = " + "copy %s %s" % (src, os.path.normpath(dir))
    
    # Some build commands depend on the platform - eg MS .NET Windows Vs Mono on Linux
    if platform.system() == "Windows":
        os.system ("copy %s %s" % (src, os.path.normpath(dir)))
        msbuildCommand = "%WinDir%\\Microsoft.NET\\Framework\\v3.5\\msbuild.exe"
    else:
        os.system ("cp %s/*  %s" % (src, os.path.normpath(dir)))
        msbuildCommand = "xbuild"
    
    # Compile for the 'Normal' .Net framework
    print("Compiling Assembly for .Net Framework 3.5")
    os.system ("%s %s" % (msbuildCommand, os.path.normpath(dir + "/Mavlink_Net3_5.csproj")))
    
    # Compile for the .Net Micro Framework
    if platform.system() == "Windows":
        print("Compiling Assembly for .Net Micro Framework 4.1")
        msbuildCommand = "%WinDir%\\Microsoft.NET\\Framework\\v4.0.30319\\msbuild.exe"
        os.system ("%s %s" % (msbuildCommand, os.path.normpath(dir + "/Mavlink_uFramework4_1.csproj")))
    else:
        print("Skipping Compiling Assembly for .Net Micro Framework 4.1 - Not supported on Mono")
    
    
    print("Generated %s OK" % filename)
